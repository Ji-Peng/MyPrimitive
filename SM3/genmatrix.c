#include "genmatrix.h"
#include <immintrin.h>
#include <string.h>
#include "polyvec.h"
#include "sm3kdf.h"

/* Generate entry a_{i,j} of matrix A as Parse(SHAKE128(seed|i|j)) */
#define NBLOCKS 4

static const unsigned char idx[256][8] = {
    {0, 0, 0, 0, 0, 0, 0, 0},    {0, 0, 0, 0, 0, 0, 0, 0},
    {2, 0, 0, 0, 0, 0, 0, 0},    {0, 2, 0, 0, 0, 0, 0, 0},
    {4, 0, 0, 0, 0, 0, 0, 0},    {0, 4, 0, 0, 0, 0, 0, 0},
    {2, 4, 0, 0, 0, 0, 0, 0},    {0, 2, 4, 0, 0, 0, 0, 0},
    {6, 0, 0, 0, 0, 0, 0, 0},    {0, 6, 0, 0, 0, 0, 0, 0},
    {2, 6, 0, 0, 0, 0, 0, 0},    {0, 2, 6, 0, 0, 0, 0, 0},
    {4, 6, 0, 0, 0, 0, 0, 0},    {0, 4, 6, 0, 0, 0, 0, 0},
    {2, 4, 6, 0, 0, 0, 0, 0},    {0, 2, 4, 6, 0, 0, 0, 0},
    {8, 0, 0, 0, 0, 0, 0, 0},    {0, 8, 0, 0, 0, 0, 0, 0},
    {2, 8, 0, 0, 0, 0, 0, 0},    {0, 2, 8, 0, 0, 0, 0, 0},
    {4, 8, 0, 0, 0, 0, 0, 0},    {0, 4, 8, 0, 0, 0, 0, 0},
    {2, 4, 8, 0, 0, 0, 0, 0},    {0, 2, 4, 8, 0, 0, 0, 0},
    {6, 8, 0, 0, 0, 0, 0, 0},    {0, 6, 8, 0, 0, 0, 0, 0},
    {2, 6, 8, 0, 0, 0, 0, 0},    {0, 2, 6, 8, 0, 0, 0, 0},
    {4, 6, 8, 0, 0, 0, 0, 0},    {0, 4, 6, 8, 0, 0, 0, 0},
    {2, 4, 6, 8, 0, 0, 0, 0},    {0, 2, 4, 6, 8, 0, 0, 0},
    {10, 0, 0, 0, 0, 0, 0, 0},   {0, 10, 0, 0, 0, 0, 0, 0},
    {2, 10, 0, 0, 0, 0, 0, 0},   {0, 2, 10, 0, 0, 0, 0, 0},
    {4, 10, 0, 0, 0, 0, 0, 0},   {0, 4, 10, 0, 0, 0, 0, 0},
    {2, 4, 10, 0, 0, 0, 0, 0},   {0, 2, 4, 10, 0, 0, 0, 0},
    {6, 10, 0, 0, 0, 0, 0, 0},   {0, 6, 10, 0, 0, 0, 0, 0},
    {2, 6, 10, 0, 0, 0, 0, 0},   {0, 2, 6, 10, 0, 0, 0, 0},
    {4, 6, 10, 0, 0, 0, 0, 0},   {0, 4, 6, 10, 0, 0, 0, 0},
    {2, 4, 6, 10, 0, 0, 0, 0},   {0, 2, 4, 6, 10, 0, 0, 0},
    {8, 10, 0, 0, 0, 0, 0, 0},   {0, 8, 10, 0, 0, 0, 0, 0},
    {2, 8, 10, 0, 0, 0, 0, 0},   {0, 2, 8, 10, 0, 0, 0, 0},
    {4, 8, 10, 0, 0, 0, 0, 0},   {0, 4, 8, 10, 0, 0, 0, 0},
    {2, 4, 8, 10, 0, 0, 0, 0},   {0, 2, 4, 8, 10, 0, 0, 0},
    {6, 8, 10, 0, 0, 0, 0, 0},   {0, 6, 8, 10, 0, 0, 0, 0},
    {2, 6, 8, 10, 0, 0, 0, 0},   {0, 2, 6, 8, 10, 0, 0, 0},
    {4, 6, 8, 10, 0, 0, 0, 0},   {0, 4, 6, 8, 10, 0, 0, 0},
    {2, 4, 6, 8, 10, 0, 0, 0},   {0, 2, 4, 6, 8, 10, 0, 0},
    {12, 0, 0, 0, 0, 0, 0, 0},   {0, 12, 0, 0, 0, 0, 0, 0},
    {2, 12, 0, 0, 0, 0, 0, 0},   {0, 2, 12, 0, 0, 0, 0, 0},
    {4, 12, 0, 0, 0, 0, 0, 0},   {0, 4, 12, 0, 0, 0, 0, 0},
    {2, 4, 12, 0, 0, 0, 0, 0},   {0, 2, 4, 12, 0, 0, 0, 0},
    {6, 12, 0, 0, 0, 0, 0, 0},   {0, 6, 12, 0, 0, 0, 0, 0},
    {2, 6, 12, 0, 0, 0, 0, 0},   {0, 2, 6, 12, 0, 0, 0, 0},
    {4, 6, 12, 0, 0, 0, 0, 0},   {0, 4, 6, 12, 0, 0, 0, 0},
    {2, 4, 6, 12, 0, 0, 0, 0},   {0, 2, 4, 6, 12, 0, 0, 0},
    {8, 12, 0, 0, 0, 0, 0, 0},   {0, 8, 12, 0, 0, 0, 0, 0},
    {2, 8, 12, 0, 0, 0, 0, 0},   {0, 2, 8, 12, 0, 0, 0, 0},
    {4, 8, 12, 0, 0, 0, 0, 0},   {0, 4, 8, 12, 0, 0, 0, 0},
    {2, 4, 8, 12, 0, 0, 0, 0},   {0, 2, 4, 8, 12, 0, 0, 0},
    {6, 8, 12, 0, 0, 0, 0, 0},   {0, 6, 8, 12, 0, 0, 0, 0},
    {2, 6, 8, 12, 0, 0, 0, 0},   {0, 2, 6, 8, 12, 0, 0, 0},
    {4, 6, 8, 12, 0, 0, 0, 0},   {0, 4, 6, 8, 12, 0, 0, 0},
    {2, 4, 6, 8, 12, 0, 0, 0},   {0, 2, 4, 6, 8, 12, 0, 0},
    {10, 12, 0, 0, 0, 0, 0, 0},  {0, 10, 12, 0, 0, 0, 0, 0},
    {2, 10, 12, 0, 0, 0, 0, 0},  {0, 2, 10, 12, 0, 0, 0, 0},
    {4, 10, 12, 0, 0, 0, 0, 0},  {0, 4, 10, 12, 0, 0, 0, 0},
    {2, 4, 10, 12, 0, 0, 0, 0},  {0, 2, 4, 10, 12, 0, 0, 0},
    {6, 10, 12, 0, 0, 0, 0, 0},  {0, 6, 10, 12, 0, 0, 0, 0},
    {2, 6, 10, 12, 0, 0, 0, 0},  {0, 2, 6, 10, 12, 0, 0, 0},
    {4, 6, 10, 12, 0, 0, 0, 0},  {0, 4, 6, 10, 12, 0, 0, 0},
    {2, 4, 6, 10, 12, 0, 0, 0},  {0, 2, 4, 6, 10, 12, 0, 0},
    {8, 10, 12, 0, 0, 0, 0, 0},  {0, 8, 10, 12, 0, 0, 0, 0},
    {2, 8, 10, 12, 0, 0, 0, 0},  {0, 2, 8, 10, 12, 0, 0, 0},
    {4, 8, 10, 12, 0, 0, 0, 0},  {0, 4, 8, 10, 12, 0, 0, 0},
    {2, 4, 8, 10, 12, 0, 0, 0},  {0, 2, 4, 8, 10, 12, 0, 0},
    {6, 8, 10, 12, 0, 0, 0, 0},  {0, 6, 8, 10, 12, 0, 0, 0},
    {2, 6, 8, 10, 12, 0, 0, 0},  {0, 2, 6, 8, 10, 12, 0, 0},
    {4, 6, 8, 10, 12, 0, 0, 0},  {0, 4, 6, 8, 10, 12, 0, 0},
    {2, 4, 6, 8, 10, 12, 0, 0},  {0, 2, 4, 6, 8, 10, 12, 0},
    {14, 0, 0, 0, 0, 0, 0, 0},   {0, 14, 0, 0, 0, 0, 0, 0},
    {2, 14, 0, 0, 0, 0, 0, 0},   {0, 2, 14, 0, 0, 0, 0, 0},
    {4, 14, 0, 0, 0, 0, 0, 0},   {0, 4, 14, 0, 0, 0, 0, 0},
    {2, 4, 14, 0, 0, 0, 0, 0},   {0, 2, 4, 14, 0, 0, 0, 0},
    {6, 14, 0, 0, 0, 0, 0, 0},   {0, 6, 14, 0, 0, 0, 0, 0},
    {2, 6, 14, 0, 0, 0, 0, 0},   {0, 2, 6, 14, 0, 0, 0, 0},
    {4, 6, 14, 0, 0, 0, 0, 0},   {0, 4, 6, 14, 0, 0, 0, 0},
    {2, 4, 6, 14, 0, 0, 0, 0},   {0, 2, 4, 6, 14, 0, 0, 0},
    {8, 14, 0, 0, 0, 0, 0, 0},   {0, 8, 14, 0, 0, 0, 0, 0},
    {2, 8, 14, 0, 0, 0, 0, 0},   {0, 2, 8, 14, 0, 0, 0, 0},
    {4, 8, 14, 0, 0, 0, 0, 0},   {0, 4, 8, 14, 0, 0, 0, 0},
    {2, 4, 8, 14, 0, 0, 0, 0},   {0, 2, 4, 8, 14, 0, 0, 0},
    {6, 8, 14, 0, 0, 0, 0, 0},   {0, 6, 8, 14, 0, 0, 0, 0},
    {2, 6, 8, 14, 0, 0, 0, 0},   {0, 2, 6, 8, 14, 0, 0, 0},
    {4, 6, 8, 14, 0, 0, 0, 0},   {0, 4, 6, 8, 14, 0, 0, 0},
    {2, 4, 6, 8, 14, 0, 0, 0},   {0, 2, 4, 6, 8, 14, 0, 0},
    {10, 14, 0, 0, 0, 0, 0, 0},  {0, 10, 14, 0, 0, 0, 0, 0},
    {2, 10, 14, 0, 0, 0, 0, 0},  {0, 2, 10, 14, 0, 0, 0, 0},
    {4, 10, 14, 0, 0, 0, 0, 0},  {0, 4, 10, 14, 0, 0, 0, 0},
    {2, 4, 10, 14, 0, 0, 0, 0},  {0, 2, 4, 10, 14, 0, 0, 0},
    {6, 10, 14, 0, 0, 0, 0, 0},  {0, 6, 10, 14, 0, 0, 0, 0},
    {2, 6, 10, 14, 0, 0, 0, 0},  {0, 2, 6, 10, 14, 0, 0, 0},
    {4, 6, 10, 14, 0, 0, 0, 0},  {0, 4, 6, 10, 14, 0, 0, 0},
    {2, 4, 6, 10, 14, 0, 0, 0},  {0, 2, 4, 6, 10, 14, 0, 0},
    {8, 10, 14, 0, 0, 0, 0, 0},  {0, 8, 10, 14, 0, 0, 0, 0},
    {2, 8, 10, 14, 0, 0, 0, 0},  {0, 2, 8, 10, 14, 0, 0, 0},
    {4, 8, 10, 14, 0, 0, 0, 0},  {0, 4, 8, 10, 14, 0, 0, 0},
    {2, 4, 8, 10, 14, 0, 0, 0},  {0, 2, 4, 8, 10, 14, 0, 0},
    {6, 8, 10, 14, 0, 0, 0, 0},  {0, 6, 8, 10, 14, 0, 0, 0},
    {2, 6, 8, 10, 14, 0, 0, 0},  {0, 2, 6, 8, 10, 14, 0, 0},
    {4, 6, 8, 10, 14, 0, 0, 0},  {0, 4, 6, 8, 10, 14, 0, 0},
    {2, 4, 6, 8, 10, 14, 0, 0},  {0, 2, 4, 6, 8, 10, 14, 0},
    {12, 14, 0, 0, 0, 0, 0, 0},  {0, 12, 14, 0, 0, 0, 0, 0},
    {2, 12, 14, 0, 0, 0, 0, 0},  {0, 2, 12, 14, 0, 0, 0, 0},
    {4, 12, 14, 0, 0, 0, 0, 0},  {0, 4, 12, 14, 0, 0, 0, 0},
    {2, 4, 12, 14, 0, 0, 0, 0},  {0, 2, 4, 12, 14, 0, 0, 0},
    {6, 12, 14, 0, 0, 0, 0, 0},  {0, 6, 12, 14, 0, 0, 0, 0},
    {2, 6, 12, 14, 0, 0, 0, 0},  {0, 2, 6, 12, 14, 0, 0, 0},
    {4, 6, 12, 14, 0, 0, 0, 0},  {0, 4, 6, 12, 14, 0, 0, 0},
    {2, 4, 6, 12, 14, 0, 0, 0},  {0, 2, 4, 6, 12, 14, 0, 0},
    {8, 12, 14, 0, 0, 0, 0, 0},  {0, 8, 12, 14, 0, 0, 0, 0},
    {2, 8, 12, 14, 0, 0, 0, 0},  {0, 2, 8, 12, 14, 0, 0, 0},
    {4, 8, 12, 14, 0, 0, 0, 0},  {0, 4, 8, 12, 14, 0, 0, 0},
    {2, 4, 8, 12, 14, 0, 0, 0},  {0, 2, 4, 8, 12, 14, 0, 0},
    {6, 8, 12, 14, 0, 0, 0, 0},  {0, 6, 8, 12, 14, 0, 0, 0},
    {2, 6, 8, 12, 14, 0, 0, 0},  {0, 2, 6, 8, 12, 14, 0, 0},
    {4, 6, 8, 12, 14, 0, 0, 0},  {0, 4, 6, 8, 12, 14, 0, 0},
    {2, 4, 6, 8, 12, 14, 0, 0},  {0, 2, 4, 6, 8, 12, 14, 0},
    {10, 12, 14, 0, 0, 0, 0, 0}, {0, 10, 12, 14, 0, 0, 0, 0},
    {2, 10, 12, 14, 0, 0, 0, 0}, {0, 2, 10, 12, 14, 0, 0, 0},
    {4, 10, 12, 14, 0, 0, 0, 0}, {0, 4, 10, 12, 14, 0, 0, 0},
    {2, 4, 10, 12, 14, 0, 0, 0}, {0, 2, 4, 10, 12, 14, 0, 0},
    {6, 10, 12, 14, 0, 0, 0, 0}, {0, 6, 10, 12, 14, 0, 0, 0},
    {2, 6, 10, 12, 14, 0, 0, 0}, {0, 2, 6, 10, 12, 14, 0, 0},
    {4, 6, 10, 12, 14, 0, 0, 0}, {0, 4, 6, 10, 12, 14, 0, 0},
    {2, 4, 6, 10, 12, 14, 0, 0}, {0, 2, 4, 6, 10, 12, 14, 0},
    {8, 10, 12, 14, 0, 0, 0, 0}, {0, 8, 10, 12, 14, 0, 0, 0},
    {2, 8, 10, 12, 14, 0, 0, 0}, {0, 2, 8, 10, 12, 14, 0, 0},
    {4, 8, 10, 12, 14, 0, 0, 0}, {0, 4, 8, 10, 12, 14, 0, 0},
    {2, 4, 8, 10, 12, 14, 0, 0}, {0, 2, 4, 8, 10, 12, 14, 0},
    {6, 8, 10, 12, 14, 0, 0, 0}, {0, 6, 8, 10, 12, 14, 0, 0},
    {2, 6, 8, 10, 12, 14, 0, 0}, {0, 2, 6, 8, 10, 12, 14, 0},
    {4, 6, 8, 10, 12, 14, 0, 0}, {0, 4, 6, 8, 10, 12, 14, 0},
    {2, 4, 6, 8, 10, 12, 14, 0}, {0, 2, 4, 6, 8, 10, 12, 14}};
static const unsigned int popcount[256] = {
    0, 1, 1, 2, 1, 2, 2, 3, 1, 2, 2, 3, 2, 3, 3, 4, 1, 2, 2, 3, 2, 3, 3, 4,
    2, 3, 3, 4, 3, 4, 4, 5, 1, 2, 2, 3, 2, 3, 3, 4, 2, 3, 3, 4, 3, 4, 4, 5,
    2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6, 1, 2, 2, 3, 2, 3, 3, 4,
    2, 3, 3, 4, 3, 4, 4, 5, 2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6,
    2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6, 3, 4, 4, 5, 4, 5, 5, 6,
    4, 5, 5, 6, 5, 6, 6, 7, 1, 2, 2, 3, 2, 3, 3, 4, 2, 3, 3, 4, 3, 4, 4, 5,
    2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6, 2, 3, 3, 4, 3, 4, 4, 5,
    3, 4, 4, 5, 4, 5, 5, 6, 3, 4, 4, 5, 4, 5, 5, 6, 4, 5, 5, 6, 5, 6, 6, 7,
    2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6, 3, 4, 4, 5, 4, 5, 5, 6,
    4, 5, 5, 6, 5, 6, 6, 7, 3, 4, 4, 5, 4, 5, 5, 6, 4, 5, 5, 6, 5, 6, 6, 7,
    4, 5, 5, 6, 5, 6, 6, 7, 5, 6, 6, 7, 6, 7, 7, 8};

static int rej_sample(uint16_t *r, size_t rlen, const unsigned char *buf,
                      size_t buflen) {
  // ctr: control word
  // pos: position
  unsigned int ctr, pos;
  // val: value
  uint16_t val;
  // the number of the eligible 16-bits
  uint32_t goodNum;
  // q16x = [q, q, q, ..., q] there are 16 Q
  const __m256i q16x = _mm256_set1_epi16(AKCN_Q);
  // mask16x = [0x1fff, 0x1fff, ..., 0x1fff] there are 16 0x1fff
  const __m256i mask16 = _mm256_set1_epi16(0x1fff);
  // ones = [1, 1, ..., 1] there are 32 1
  const __m256i ones = _mm256_set1_epi8(1);
  //
  __m256i d0, tmp0, pi0;
  // pilo: pi low, pihi: pi high
  __m128i d, tmp, pilo, pihi;

  ctr = pos = 0;
  while (ctr + 16 < rlen) {
    // d0[255:0]=MEM[&buf[pos]+255:&buf[pos]]
    d0 = _mm256_loadu_si256((__m256i *)&buf[pos]);
    // d0[0]=d0[0]&buf[pos],d0[1]=d0[1]&buf[pos+1],...
    d0 = _mm256_and_si256(d0, mask16);
    /*
    _mm256_cmpgt_epi16 (__m256i a, __m256i b)
    FOR j := 0 to 15
        i := j*16
        dst[i+15:i] := ( a[i+15:i] > b[i+15:i] ) ? 0xFFFF : 0
    ENDFOR
    dst[MAX:256] := 0
    */
    // tmp0 = [0xFFFF, 0, ...]
    tmp0 = _mm256_cmpgt_epi16(q16x, d0);
    /*
    Create mask from the most significant bit of each 8-bit element in a, and
    store the result in dst. good is not the number of eligible 16-bits now
    */
    // good = 1100...B
    goodNum = _mm256_movemask_epi8(tmp0);
    // good = 10...B, now good is the number of eligible 16-bits now
    goodNum = _pext_u32(goodNum, 0x55555555);
    /*
    _mm_loadl_epi64
    dst[63:0] := MEM[mem_addr+63:mem_addr]
    dst[MAX:64] := 0
    */
    // goodNum=0, goodNum&0xFF=0, idx[0], pilo=pihi={0,0,...,0,0,0,0,0,0,0,0,0}
    // goodNum=2, goodNum&0xFF=2, idx[2], pilo={0,...,0,2,0,0,0,0,0,0,0}
    // pihi={0,...0,0,0,0,0,0,0,0,0}
    pilo = _mm_loadl_epi64((__m128i *)&idx[goodNum & 0xFF]);
    pihi = _mm_loadl_epi64((__m128i *)&idx[(goodNum >> 8) & 0xFF]);
    // cast _m128i to _m256i
    pi0 = _mm256_castsi128_si256(pilo);
    // pi0 = pihi || pilo
    pi0 = _mm256_inserti128_si256(pi0, pihi, 1);
    /*
    _mm256_add_epi8
    FOR j := 0 to 31
        i := j*8
        dst[i+7:i] := a[i+7:i] + b[i+7:i]
    ENDFOR
    dst[MAX:256] := 0
    */
   //goodNum=2,tmp0={1,...,1,1,...,1,1,...,1,3,1,...,1}
    tmp0 = _mm256_add_epi8(pi0, ones);
    //Unpack and interleave 8-bit integers from the low half of each 128-bit lane in a and b, and store the results in dst
    pi0 = _mm256_unpacklo_epi8(pi0, tmp0);
    //i do not know what is the significance of pi0, maybe mask
    d0 = _mm256_shuffle_epi8(d0, pi0);
    //...
    _mm_storeu_si128((__m128i *)&r[ctr], _mm256_castsi256_si128(d0));
    ctr += popcount[goodNum & 0xFF];
    _mm_storeu_si128((__m128i *)&r[ctr], _mm256_extracti128_si256(d0, 1));
    ctr += popcount[(goodNum >> 8) & 0xFF];

    pos += 32;

    if (pos > buflen - 32) return ctr;
  }

  while (ctr + 8 < rlen) {
    d = _mm_loadu_si128((__m128i *)&buf[pos]);
    d = _mm_and_si128(d, _mm256_castsi256_si128(mask16));
    tmp = _mm_cmpgt_epi16(_mm256_castsi256_si128(q16x), d);
    goodNum = _mm_movemask_epi8(tmp);
    goodNum = _pext_u32(goodNum, 0x55555555);
    pilo = _mm_loadl_epi64((__m128i *)&idx[goodNum]);
    pihi = _mm_add_epi8(pilo, _mm256_castsi256_si128(ones));
    pilo = _mm_unpacklo_epi8(pilo, pihi);
    d = _mm_shuffle_epi8(d, pilo);

    _mm_storeu_si128((__m128i *)&r[ctr], d);
    ctr += popcount[goodNum & 0xFF];
    pos += 16;

    if (pos > buflen - 16) return ctr;
  }
  while (ctr < rlen) {
    val = (buf[pos] | ((uint16_t)buf[pos + 1] << 8)) & 0x1fff;

    pos += 2;

    if (val < AKCN_Q) r[ctr++] = val;

    if (pos > buflen - 2) return ctr;
  }
  return 0;
}

/*******************************************
 * Name:    gen_matrix
 *
 * Description:
 *
 * Arguments: polyvec * a:
 * Arguments: const unsigned char * seed:
 * Arguments: int transposed:
 *
 * Returns: void:
 *******************************************/
void gen_matrix(polyvec *a, const unsigned char *seed, int transposed) {
  unsigned int i, j, ctr, t;
  unsigned char __declspec(align(32)) buf[128 * (NBLOCKS + 1)];

  sm3kdf_ctx state;
  // init the state
  sm3_kdf_init(&state, seed, 32, 0);

  // double loop for the generating of polyvec *a
  for (i = 0; i < AKCN_K; i++) {
    for (j = 0; j < AKCN_K; j++) {
      // transposed = 0 is different between transposed = 1
      if (transposed)
        sm3_kdf_select(&state, (i << 8) + j);
      else
        sm3_kdf_select(&state, (j << 8) + i);

      // buf is the output of sm3
      sm3_kdf_squeezeblocks(buf, NBLOCKS + 1, &state);

      ctr = 0;
      //coeffs[ctr:MAX] is not eligible
      t = rej_sample(a[i].vec[j].coeffs, AKCN_N, buf, 128 * NBLOCKS);

      while (t) {
        ctr += t;
        sm3_kdf_squeezeblocks(buf, 1, &state);
        t = rej_sample(&a[i].vec[j].coeffs[ctr], AKCN_N - ctr, buf, 128);
      }
    }
  }
}